---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Zino Lath.
--- DateTime: 18/07/2021 01:00
---
--- To make a submenu, you first need to define it in the menu table.
--- you define the function in an never ending coroutine, always doing
--- coroutine.yield on the function. Then you create the coroutine using
--- coroutine.create, and attach it to M.coroutine (where M is the table
--- you're storing your values in).
--- In the coroutine function, you will do whatever you want the menu to do
--- **while the menu is the active one**, like switching up the selected
--- option, getting key states, and so on. This effectively freezes your
--- menu when it's not the main one, but doesn't delete/create your stuff.
--- you can still create objects that are updated every frame, no buts, which
--- is useful for transitions, but be sure to not put any meaningful input
--- there, to avoid it getting inputs when it's not their turn to do stuff.
---
--- To create a special transition, define the M._in and M._out functions
--- using normal task.Wait's, but not making a task for the whole transition.
--- It is important to not create another task, since they're already going
--- to be spawned in one, and the usage of tasks might allow for behavior
--- like waiting for the M.in function to finish to do a M.out function.
---
--- If you need to get the actual stage object, refer to stage_init (global).
--- That's how you get the current menu stack (use [0] to get the current one,
--- -1 to get the one behind the current one, so on.) To know which menu is
--- the active one by name, try doing stage_init.stack[0].name.
---

LoadImageFromFile('menu_reimu', "THlib\\menu\\assets\\reimu_title.png", false, 0,0,false)
LoadImageFromFile('gamelogo', "THlib\\menu\\assets\\gamelogo.png", false, 0,0,false)
local m = lstg.menu
m.title_screen = {}
local M = m.title_screen
M.name = "title_screen"
M.obj_list = {}
local t = lstg.text.menu
local t_ids = {"start_game","extra_start","stage_practice","spell_practice","music_room","replay","manual","options","exit"}
local font_ids = {
    start_game = "start",
    extra_start = "extra",
    stage_practice = "stpr",
    spell_practice = "scpr",
    music_room = "mscr",
    replay = "replay",
    manual = "manual",
    options = "options",
    exit = "exit"
}
M.selected = 1

function M.update()
    for id, text in ipairs(t_ids) do
        M.obj_list[id] = New(M.option,text,id)
    end
    --DEBUG_TEXT = "sex 2 for the nintendo switch"
    M.desc_obj = New(M.desc)
    M._in()
    while(true)do
        if(m.key.up) then
            PlaySound('select00')
            M.wrap_menu(-1)
        elseif(m.key.down) then
            PlaySound('select00')
            M.wrap_menu(1)
        end
        if(KeyIsPressed('shoot')) then
            PlaySound('ok00')
            M[t_ids[M.selected]].func()
        end
        if(KeyIsPressed('spell')) then
            if(M.selected == #t_ids) then
                PlaySound('ok00')
                M[t_ids[M.selected]].func()
            else
                PlaySound('cancel00')
            end
            M.wrap_menu(#t_ids-M.selected)
        end
        coroutine.yield()
    end
end

function M._in()
    M.desc_obj:transition(255)
    if IsValid(M.reimuobj) then Del(M.reimuobj) end
    M.reimuobj = New(M.reimu_class)
    task.New(stage_init, function()
        for _, obj in ipairs(M.obj_list) do
            task.New(stage_init,function()
                if not IsValid(obj) then return end
                obj:_in()
            end)
            task.Wait(2)
        end
    end)
    task.Wait(30)
    M.obj_list[M.selected]:_select()
end
function M._out()
    Kill(M.reimuobj)
    M.desc_obj:transition(0)
    task.New(stage_init, function()
        for _, obj in ipairs(M.obj_list) do
            task.New(stage_init,function()
                obj:_out()
            end)
            task.Wait(2)
        end
    end)
end

M.option = Class(object)
function M.option:init(t_id,id)
    self.scale = 0.65
    self.x = -150
    self.postx = M.getposition(id,0.75).x
    self.prex = self.x
    self.y = M.getposition(id,0.75).y
    self.bound = false
    if(t[t_id] == nil) then
        error(t_id)
    end
    self.t_id = t_id
    self.id = id
    self._in = M.option._in
    self._out = M.option._out
    self._select = M.option._select
    self._unselect = M.option._unselect
    self._a = 128
end
function M.option:render()
    local font = "title_" .. font_ids[self.t_id]
    SetColorFont(font,Color(self._a,255,255,255))
    RenderMenuText(font, self.t_id, false, self.x, self.y, self.scale, 'left', "vcenter")
end
function M.option:_in()
    local px = self.x
    local ex = self.postx
    for i=0, 1, 1/60 do
        self.x = Interpolate(px, ex, EaseOutCubic(i))
        task.Wait(1)
    end
end
function M.option:_out()
    local px = self.postx
    local ex = self.prex
    for i=0, 1, 1/60 do
        self.x = Interpolate(px, ex, EaseOutCubic(i))
        task.Wait(1)
    end
end
function M.option:_select()
    local px = self.x
    local ex = self.x + 30
    local pa = self._a
    local ea = 255
    for i=0, 1, 1/20 do
        self.x = Interpolate(px, ex, EaseOutCubic(i))
        self._a = Interpolate(pa, ea, EaseOutCubic(i))
        task.Wait(1)
    end
end
function M.option:_unselect()
    local px = self.x
    local ex = self.postx
    local pa = self._a
    local ea = 128
    for i=0, 1, 1/20 do
        self.x = Interpolate(px, ex, EaseOutCubic(i))
        self._a = Interpolate(pa, ea, EaseOutCubic(i))
        task.Wait(1)
    end
end

M.desc = Class(object)
function M.desc:init()
    self.x = 320
    self.y = 20
    self.bound = false
    self.text = t[t_ids[M.selected]].desc
    self._a = 0
    self.transition = M.desc.transition
    self.layer = -1
    self.font = string.format("title_%s_desc",font_ids[t_ids[M.selected]])
end
function M.desc:frame()
    task.Do(self)
end
function M.desc:render()
    SetColorFont(self.font,Color(self._a,255,255,255))
    RenderFont(self.font, self.text, self.x, self.y, 0.5, 'center', "vcenter")
end
function M.desc:transition(end_a)
    self.task = {}
    self.task[1] = task.New(self,function()
        local pa = self._a
        local ma = 0
        local ea = end_a
        for i=0, 1, 1/5 do
            self._a = Interpolate(pa, ma, EaseOutCubic(i))
            task.Wait(1)
        end
        self.text = t[t_ids[M.selected]].desc
        self.font = string.format("title_%s_desc",font_ids[t_ids[M.selected]])
        for i=0, 1, 1/15 do
            self._a = Interpolate(ma, ea, EaseOutCubic(i))
            task.Wait(1)
        end
    end)
end

function M.getposition(id, scale)
    local ang = ((id - 1) * 9 / (#t_ids-1)) * 20
    return {
        x = 40 * scale + 20 * scale * sin(ang) + 10 * id * scale,
        y = 500 - (150 + id * 40 * scale)
    }
end

M.reimu_class = Class(object)
function M.reimu_class:init()
    self.bound = false
    self.x, self.y = 450,240
    self.alpha = 0
    task.New(self,function()
        for i=0, 1, 1/30 do
            self.alpha = EaseOutCubic(i) * 255
            coroutine.yield()
        end
        self.alpha = 255
    end)
end
function M.reimu_class:render()
    SetImageState("gamelogo", "", Color(self.alpha,255,255,255))
    Render('gamelogo', 150,410,0,0.75,0.75)
    SetImageState("menu_reimu", "", Color(self.alpha,255,255,255))
    Render("menu_reimu", self.x, self.y + 20 * sin(self.timer/2), 5*sin(self.timer), 0.17,0.17)
end
M.reimu_class.frame = task.Do
function M.reimu_class:kill()
    PreserveObject(self)
    task.Clear(self)
    task.New(self, function()
        for i=0, 1, 1/30 do
            self.alpha = EaseOutCubic(1-i) * 255
            coroutine.yield()
        end
        self.alpha = 0
        Del(self)
    end)
end

function M.wrap_menu(change)
    local obj = M.obj_list[M.selected]
    task.New(stage_init, function()
        obj:_unselect()
    end)

    if(M.selected + change > #t_ids) then
        M.selected = 1
    elseif(M.selected + change < 1) then
        M.selected = #t_ids
    else
        M.selected = M.selected + change
    end

    M.desc_obj:transition(255)

    local obj2 = M.obj_list[M.selected]
    task.New(stage_init, function()
        obj2:_select()
    end)
end
M.exit = {}
function M.exit.func()
    lstg.quit_flag = true
end
M.start_game = {}
function M.start_game.func()
    practice = false
    M._out()
    task.Wait(15)
    m.start_game._in()
    stage_init.stack:push(m.start_game)
end
M.extra_start = {}
function M.extra_start.func()
    practice = false
    if(scoredata.ex_unlocked) then
        M._out()
        task.Wait(15)
        m.extra_start._in()
        stage_init.stack:push(m.extra_start)
    else
        PlaySound('invalid', 0.5)
    end
end
M.spell_practice = {}
function M.spell_practice.func()
    M._out()
    task.Wait(15)
    stage_init.stack:push(m.spell_practice)
    coroutine.resume(m.spell_practice.coroutine)
    m.spell_practice._in()
end

M.replay = {}
function M.replay.func()
    M._out()
    task.Wait(15)
    stage_init.stack:push(m.replay)
    coroutine.resume(m.replay.coroutine)
    m.replay._in()
end

M.options = {}
function M.options.func()
    M._out()
    task.Wait(15)
    stage_init.stack:push(m.options)
    coroutine.resume(m.options.coroutine)
    m.options._in()
end

M.stage_practice = {}
function M.stage_practice.func()
    practice = true
    M._out()
    task.Wait(15)
    m.start_game._in()
    stage_init.stack:push(m.start_game)
end

M.music_room = {}
function M.music_room.func()
    M._out()
    task.Wait(15)
    m.music_room._in()
    stage_init.stack:push(m.music_room)
end

M.manual = {}
function M.manual.func()
    hey_bestie()
end