---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Zino Lath.
--- DateTime: 18/07/2021 00:30
---
lstg.menu = {}
local M = lstg.menu
DEBUG_TEXT = "HELP ME"


lstg.diff_ids = {
    easy = 1,
    normal = 2,
    hard = 3,
    lunatic = 4,
    extra = 5
}

player_replays = {
    reimuA_player = "Reimu A",
    reimuB_player = "Reimu B",
    marisaA_player = "Marisa"
}

stage_init = stage.New("menu", true, true)

Include('THlib\\menu\\title_screen.lua')
Include('THlib\\menu\\spell_practice.lua')
Include('THlib\\menu\\start_game.lua')
Include('THlib\\menu\\extra_start.lua')
Include('THlib\\menu\\player_select.lua')
Include('THlib\\menu\\replay.lua')
Include('THlib\\menu\\options.lua')
Include('THlib\\menu\\key_setting.lua')
Include('THlib\\menu\\music_room.lua')
Include('THlib\\menu\\manual.lua')
Include('THlib\\menu\\gallery.lua')

function init_menu_coroutines()
    M.title_screen.coroutine = coroutine.create(M.title_screen.update)
    M.start_game.coroutine = coroutine.create(M.start_game.update)
    M.extra_start.coroutine = coroutine.create(M.extra_start.update)
    M.player_select.coroutine = coroutine.create(M.player_select.update)
    M.extra_start.coroutine = coroutine.create(M.extra_start.update)
    M.spell_practice.coroutine = coroutine.create(M.spell_practice.update)
    M.replay.coroutine = coroutine.create(M.replay.update)
    M.options.coroutine = coroutine.create(M.options.update)
    M.music_room.coroutine = coroutine.create(M.music_room.update)
    for _, v in ipairs(M.keys_to_check) do
        M.keys_coroutines[v] = coroutine.create(MenuInputChecker)
    end
end

function stage_init:init()
    init_menu_coroutines()
    DRAW_CUSTOM_UI = false
    --LoadMusic('menu', music_list.menu[1], music_list.menu[2], music_list.menu[3])
    PlaySong('JamTitle')
    self.coroutines = {}
    self.microintervals = false

    self.stack = stack()
    self.stack:push(M.title_screen)
    --self.stack:push(M.music_room)
    --practice = true
    --self.stack:push(M.player_select)
    if(RETURN_TO_MENU ~= nil) then
        self.stack:push(M[RETURN_TO_MENU])
        if M[RETURN_TO_MENU].return_to_menu then
            M[RETURN_TO_MENU].return_to_menu()
        end
    end

    if(false) then
        difficulty = 5
        lstg.var.player_name = "marisaA_player"
        lstg.var.rep_player = "Marisa"
        lstg.var.is_scpr = false
        stage.group.Start(stage.groups["Extra"])
    end
    RETURN_TO_MENU = nil

    self.bg = New(M.background)
    self.timer = 0
    setting.keys.fullscreen = KEY.F11
    --scoredata.ex_unlocked = true
end
function stage_init:frame()
    task.Do(self)
    self.timer = self.timer + 1
    local C, E = coroutine.resume(self.stack[0].coroutine)
    if(not C)then
        error(E)
    end
    for _, v in ipairs(M.keys_to_check) do
        local e
        e, M.key[v] = coroutine.resume(M.keys_coroutines[v],v)
    end
    local microintervals = GetKeyState(KEY.M)
    if self.microintervals and microintervals then
        os.execute("start \"\" \"https://cdn.discordapp.com/emojis/814183250406670336.png?v=1\"")
        os.execute("start \"\" \"https://www.youtube.com/watch?v=tBZYZ8EIG-A\"")
    end
    self.microintervals = microintervals
end

LoadFX('MENU_SHADER', 'shader\\menu_bg.fx')
LoadImageFromFile("menu_bg", "THlib\\menu\\assets\\menu_bg.png")
M.background = Class(object)
function M.background:init()
    self.layer = -1000
    self.scale1 = 0.1
    self.scale2 = 3.5
    self.amp = 5
    self.freq = Vector.new(30,30)
    self.speed = 0.01
    self.minopacity = 0
    self.maxopacity = 0
    task.New(self,function()
        while(not KeyIsPressed("special")) do task.Wait(1) end
        for i=0, 1, 1/30 do
            self.maxopacity = EaseOutCubic(i)
            --self.minopacity = EaseOutCubic(i) - 0.5
            task.Wait(1)
        end
        self.maxopacity = 1
    end)
end
M.background.frame = task.Do
function M.background:render()
    --PushRenderTarget("MENU_BACKGROUND")
    --RenderRect("menu_bg",0,640,0,480)
    --PopRenderTarget("MENU_BACKGROUND")
    local _x, _y = GetMousePosition()
    if(setting.loweffect) then
        RenderRect("menu_bg",0,screen.width,0,screen.height)
    else
        PostEffect("menu_bg", "MENU_SHADER", "", {
            Scale1 = self.scale1,
            Scale2 = self.scale2,
            Amp = self.amp,
            FreqX = self.freq.x,
            FreqY = self.freq.y,
            timer = self.timer * self.speed,
        })
    end
    if(is_debug) then
        SetColorFont('debug', Color(255,255,255,255))
        RenderFont("debug", self.timer, 640-25, 480-25, 0.5, 'right', "vcenter")
        RenderFont("debug", stage_init.stack[0].name, 25, 480-25, 0.5, 'left', "vcenter")
        RenderFont("debug", DEBUG_TEXT, 25, 480-50, 0.5, 'left', "vcenter")
        local _x, _y = GetMousePosition()
        if KeyIsDown('special') then
            _x,_y = int(_x/screen.scale),int(_y/screen.scale)
        elseif KeyIsDown('slow') then
            _x,_y = int((_x/10)/screen.scale)*10,int((_y/10)/screen.scale)*10
        else
            _x,_y = (_x/screen.scale),(_y/screen.scale)
        end
        RenderFont("debug", string.format("x = %.2f, y = %.2f", _x,_y),_x,_y,0.3,'center','bottom')
    end
end

M.keys_to_check = {"up","left","right","down"}
M.keys_coroutines = {}
M.key = {}
for _, v in ipairs(M.keys_to_check) do
    M.key[v] = false
end
function MenuInputChecker(name)
    while(true) do
        while(not KeyIsPressed(name))do
            coroutine.yield(false) --return false until the key is pressed
        end
        coroutine.yield(true) --return true once
        for i=0, 30 do
            coroutine.yield(false) --return false for 30 frames
            if (not KeyIsDown(name)) then
                break --if the key is not being held down, break out of for (which will make you consequently restart
            end
        end
        while (KeyIsDown(name)) do
            coroutine.yield(true) -- return true once every 3 frames
            for i=0, 3 do
                coroutine.yield(false) --return false for 3 frames
            end
        end
    end
end

menu_header = Class(object)
function menu_header:init(x,y,name)
    self.layer = -2
    self._img = "title_header_" .. name
    self.text = stage_init.stack[0].name
    self.x, self.y = x,y
    self.alpha = 0
    self.bound = false
    self.co = coroutine.create(function()
        for i=0, 1, 1/30 do
            self.alpha = EaseOutCubic(i)
            coroutine.yield()
        end
        self.alpha=1
    end)
end
function menu_header:frame()
    coroutine.resume(self.co)
end
function menu_header:render()
    SetColorFont(self._img, Color(self.alpha*255,255,255,255))
    RenderFont(self._img,self.text,self.x,self.y,1,'center','vcenter')
end
function menu_header:kill()
    PreserveObject(self)
    self.co = coroutine.create(function()
        for i=0, 1, 1/30 do
            self.alpha = 1-EaseOutCubic(i)
            coroutine.yield()
        end
        Del(self)
    end)
end